\section{Ausgangslage}

20 years ago the CPU was just one component of a typical music studio. It was generally used to control and synchronize other equipement such as mixing boards, multitrack recorders, synthsizers and effects processors. Today all of the other equipement exists as software, running in realtime on a CPU host. A typical music studio today is comprised of a CPU, multiple analog to digital inputs and outputs, and some DSP equiped audio processing cards.

Simliar to GPU Cards which can accelerate graphics and visualization applications, audio DSP cards can process multiple streams of high qualtiy digital audio, eliviating the load on the CPU Host Computer. Audio DSP cards typically connect to the CPU via PCI, Firewire, or Thunderbolt. Most vendors of DSP cards offer the possibility to connect several cards in parallel to increase the processing capacity.

Unlike GPU processors however, no open standard has evolved to distribute the load across multiple co processors in the way it has for openGL or openCL. 3D graphics applications profit enormously from the interoperability that openGL offers. No such benefit is available for digital audio applications. Also, unlike OpenGL applications, audio software that is developed to run on an audio DSP card cannot be run on the CPU host. This results in vendor lock-in. The consumer that invests in an audio DSP card and software, must continue to buy from the same vendor in order to build on the the initial investment. If another vendor of DSP hardware creates a superior product, a consumer is unlikely to switch platforms if a significant investment has already been made.

10 years ago this was an acceptable compromise because DSP processors connected via PCIe could provide a significant performance increase. Today however, arm based inexpensive CPUs connected via standard gigabit ethernet could offer a competative alternatvie.

\section{Ziel der Arbeit}

Das Ziel dieser Studienarbeit ist es, die Möglichkeiten für die Verteilung von Audio Verarbeitungsaufgaben für einen Software-basierten Musik Synthesizer über ein Netzwerk von SBC-Geräten (Single Board Computer) zu untersuchen. Einschränkungen in der Polyphonie oder der Prozessorleistung sollen durch einfaches Hinzufügen eines neuen Geräts im Netzwerk gelöst werden. Ein besonderes Augenmerk soll auf günstige Raspberry-Pi und ähnliche SBC Geräte gelegt werden, vor allem unter Berücksichtigung von Preis und Leistung.
Es existieren viele Standards, damit Audio Applikationen miteinander kommunizieren können. MIDI und OSC definieren Protokolle zur Steuerung von Audio- Geräten und Software. VST, AU und LW2 sind Standard Schnittstellen für Plugins, die Echtzeitaudioverarbeitung bieten. AVB ( IEEE 1722 ), Jacktrip und Dante sind Standards bzw. Software für die Übertragung von hochwertigem Audio über Ethernet mit minimaler Latenz. Diese Studienarbeit wird einige dieser Standards untersuchen, um zu eruieren, was notwendig ist, um einen skalierbaren und verteilbaren Musik-Synthesizer zu entwickeln, der mit anderen professionellen Audio Software kompatibel ist.
Eine Proof-of-Concept Version der verteilbaren Synthesizer Software wird entwickelt, welche es einem Benutzer erlauben wird, ein Musikstück in Echtzeit zu spielen.

\section{Aufgabenstellung}

\begin{itemize}

\item Anforderungsanalyse mit Prioritätsbewertung

\item Vergleich von mehreren CPUs und Embedded Systems ( Banana Pi, Adapteva, Odroid) hinsichtlich ihrer Nutzbarkeit als Echtzeit Audioverarbeitungsmodule. Mit dem System, das die Anforderungen am besten erfüllt, wird die Implementierung gemacht.

\item Entwicklung der Audioverarbeitungssoftware in C ++.

\item Entwicklung eines VST-Plugins in C++, das als Schnittstelle zwischen gängigen Audio-Software und den Audioverarbeitungsmodule (pkt 3) dient.

\item Analyse der Implementierung, um die Nützlichkeit und Skalierbarkeit zu bewerten. Es ergeben sich dadurch verschiedene Fragestellungen wie z.B. folgende: Kann die Leistung und Polyphonie durch Hinzufügen weiterer Module erhöht werden, oder wird der Kommunikations-Overhead schließlich zu gross?

\end{itemize}


